package minijava.symboltable;import java.util.Vector;public class MClasses extends MType {	public Vector mj_classes = new Vector();	//存所有的类	public MClass PClass = null;	//当前路径所在的类		public MMethod PMethod = null;	//当前路径所在的方法	public int level = 0;			//当前路径在类中(level=1)还是方法中(level=2)	public Vector now_list = null;	//参数传递时暂存的参数列表	public boolean now_flag = false;	public Vector hash_var = new Vector();	public Vector hash_method = new Vector();	public Vector hash_method_len = new Vector();	public int tab_num = 0;	public int temp_last = 0;	public int label_last = 0;	public int head, offset;	public int now_temp = 0;	public int now_temp_num = 0;	//新建一个类	public String InsertClass(MClass v_class) {		String class_name = v_class.name;		if (Repeated(class_name))			return "Class double declaration " +"\"" +class_name+"\"";		mj_classes.addElement(v_class);		return null;	}	//判定是否定义同名的类	public boolean Repeated(String class_name) {		int sz = mj_classes.size();		for (int i = 0; i < sz; i++) {			String c_name = ((MClass) mj_classes.elementAt(i)).name;			if (c_name.equals(class_name))				return true;		}		return false;	}		//打印类信息，用于调试	public void print() {		for (int i = 0; i < mj_classes.size(); ++i) {			MClass m_class = (MClass)mj_classes.elementAt(i);			m_class.print();		}	}		//检查符号表，处理继承关系	public void check_symboltable() {		for (int i = 0; i < mj_classes.size(); ++i) {			MClass m_class = (MClass)mj_classes.elementAt(i);			MClass j = m_class;			//遍历当前类的所有祖先			while (j.get_fa()) {				if (j.fa.name.equals(m_class.name)) {					System.err.println("Line"+m_class.line+":" + "circleinherit in classdeclaration");				}				class_inherit(m_class, j.fa);				j = j.fa;			}			//不存在父类			if (j.fa_name != null && j.fa == null)				System.err.println("Line"+m_class.line+":" + "extends class does not exsit");		}		//处理方法继承		for (int i = 0; i < mj_classes.size(); ++i) {			MClass m_class = (MClass)mj_classes.elementAt(i);			for (int j = 0; j < m_class.methods.size(); ++j) {				MMethod m_method = (MMethod)m_class.methods.elementAt(j);				m_method.inherit();			}		}	}		//子类继承父类的信息	public void class_inherit(MClass child, MClass ancestor){		//继承变量		for (int i = 0; i < ancestor.variables.size(); ++i) {			MVariable ancestor_var = (MVariable)ancestor.variables.elementAt(i);			boolean repeat = false;			for (int j = 0; j < child.variables.size(); ++j) {				MVariable child_var = (MVariable)child.variables.elementAt(j);				if (ancestor_var.name.equals(child_var.name)) {					repeat = true;					break;				}			}			if (!repeat) {				MVariable add_new = new MVariable(ancestor_var);				child.InsertVariable(add_new);			}		}		//继承方法		for (int i = 0; i < ancestor.methods.size(); ++i) {			MMethod ancestor_mthd = (MMethod)ancestor.methods.elementAt(i);			boolean repeat = false;			for (int j = 0; j < child.methods.size(); ++j) {				MMethod child_mthd = (MMethod)child.methods.elementAt(j);				if (ancestor_mthd.name.equals(child_mthd.name)) {					if (!ancestor_mthd.type.equals(child_mthd.type) || ancestor_mthd.para_num != child_mthd.para_num)						System.err.println("Line"+child_mthd.line+":" + " this method cannot be covered");					else {						for (int k = 0; k < child_mthd.para_num; ++k) {							MVariable v1 = (MVariable)ancestor_mthd.variables.elementAt(k);							MVariable v2 = (MVariable)child_mthd.variables.elementAt(k);							if (!v1.type.equals(v2.type) || !v1.name.equals(v2.name)) {								System.err.println("Line"+ancestor_mthd.line+":" + " this method cannot be covered in "+child.name);							}						}					}					repeat = true;					break;				}			}			if (!repeat) {				MMethod add_new = new MMethod(ancestor_mthd);				child.InsertMethod(add_new);			}		}	}	//在全局环境寻找类	public MClass find_class(String name) {		for (int i = 0; i < mj_classes.size(); ++i) {			MClass tmp = (MClass)mj_classes.elementAt(i);			if (tmp.name.equals(name))				return tmp;		}		return null;	}	//判断是否是合法类型	public boolean is_exist_type(String name) {		if (name.equals("int") || name.equals("boolean") || name.equals("int[]"))			return true;		for (int i = 0; i < mj_classes.size(); ++i) {			MClass tmp = (MClass)mj_classes.elementAt(i);			if (tmp.name.equals(name))				return true;		}		return false;	}	//寻找当前环境的变量	public MVariable find_var(String i_name) {		if (level == 1)			return PClass.find_var(i_name);		else return PMethod.find_var(i_name);	}	//判断类型b能否复制给类型a	public boolean is_derived(String a, String b) {		if (b.equals("int") || b.equals("boolean") || b.equals("int[]")) 			return b.equals(a);		MClass bb = find_class(b);		while (bb != null) {			if (bb.name.equals(a))				return true;			bb = bb.fa;		}		return false;	}		public void build_hashtable() {		for (int i = 0; i < mj_classes.size(); ++i) {			MClass m_class = (MClass)mj_classes.elementAt(i);						Vector v_list = m_class.variables;			for (int j = 0; j < v_list.size(); ++j) {				MVariable m_var = (MVariable)v_list.elementAt(j);				hash_insert(hash_var, m_var.name, 0, 0);			}						Vector m_list = m_class.methods;			for (int j = 0; j < m_list.size(); ++j) {				MMethod m_method = (MMethod)m_list.elementAt(j);				hash_insert(hash_method, m_method.name, 1, m_method.variables.size());			}		}	}		public void hash_insert(Vector v, String name, int flag, int len) {		for (int i = 0; i < v.size(); ++i) {			String tmp = (String)v.elementAt(i);			if (tmp.equals(name))				return;		}		v.addElement(name);		if (flag == 1)			hash_method_len.addElement(len);	}		public void write(String s) {		for (int i = 0; i < tab_num; ++i)			System.out.print("    ");		System.out.println(s);	}		public void get_address(String s) {		Vector list;		list = PMethod.variables;		for (int i = 0; i < list.size(); ++i) {			MVariable m_var = (MVariable)list.elementAt(i);			if (m_var.name.equals(s)) {				head = 1;				offset = i * 4;				return;			}		}		list = hash_var;		for (int i = 0; i < list.size(); ++i) {			String name = (String)list.elementAt(i);			if (name.equals(s)) {				head = 0;				offset = (i + 1) * 4;			}		}	}		public int get_method_offset(String s) {		for (int i = 0; i < hash_method.size(); ++i)			if (((String)hash_method.elementAt(i)).equals(s))				return i * 4;		return 0;	}		public int get_method_para(String s) {		for (int i = 0; i < hash_method.size(); ++i)			if (((String)hash_method.elementAt(i)).equals(s))				return (Integer)hash_method_len.elementAt(i);		return 0;	}}